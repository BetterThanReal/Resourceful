{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Resourceful: Overview \u00b6 Simplified Syntax For Resource Acquisition \u00b6 Resourceful is a Lua module that allows Roblox developers to use a simple dot notation syntax to access project resources from within their own scripts. local resources = require ( script . Parent . Resourceful ) -- Find a resource named \"MyHelpers\": local MyHelpers = resources . MyHelpers -- Find and require a ModuleScript named \"Main\": local Main = resources . require . Main Customizable, Automatic Resource Acquisition \u00b6 By default, Resourceful offers automatic resource acquisition to search for requested resources within the immediate children of Resourceful's script.Parent : local resources = require ( script . Parent . Resourceful ) -- Automatically find a resource named \"MyHelpers\", -- which is a child Instance within script.Parent: local MyHelpers = resources . MyHelpers -- Automatically find and require a ModuleScript named \"Main\", -- which is also a child Instance within script.Parent: local Main = resources . require . Main By invoking Resourceful with a custom configuration , the list of Roblox project paths that are searched during automatic resource acquisition can be specified. For example, to specify a search path consisting of script.Parent and script.Parent.Parent : local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ search = { script . Parent , script . Parent . Parent }}) --[[ Assuming the following project hierarchy: > Lib > Lib.MyLib > Lib.MyLib.Main > Lib.MyLib.MyHelpers > Lib.MyLib.Resourceful > Lib.MyLib.Script (this script) > Lib.ThirdPartyLib ]] -- -- Finds \"MyHelpers\" in Lib.MyLib (script.Parent) local MyHelpers = resources . MyHelpers -- Finds \"Main\" in Lib.MyLib (script.Parent), and requires it local Main = resources . require . Main -- Finds \"MyLib\" in Lib (script.Parent.Parent), and requires it local MyLib = resources . require . MyLib -- Finds \"ThirdPartyLib\" in Lib (script.Parent.Parent) local ThirdPartyLib = resources . ThirdPartyLib Customizable, On-Demand (Lazy-Loaded) Resource Acquisition \u00b6 Resourceful can be customized to also support the definition and creation of custom project resources , as simple or as complex as needed: local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { -- Custom resource loaders PlayerLib = function ( resources , found ) -- When \"resources.PlayerLib\" is requested, for 90% of players it should -- return the normal \"PlayerLib\" Instance child of the script parent: if math.random ( 100 ) <= 90 then return found else -- For the remaining players, \"resources.PlayerLib\" should instead -- return the \"TestPlayerLib\" Instance child of the script parent: return resources . TestPlayerLib end end , }}) -- For 10% of players, PlayerLib actually will be \"TestPlayerLib\": local PlayerLib = resources . require . PlayerLib Resourceful can be configured to support custom resources of any data type, including resource functions that return a resource. Such functions are not executed until requested, allowing on-demand, deferred, lazy-loading of resources that are cached by default for better performance: local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { -- Custom resource loaders isClient = game : GetService ( \"RunService\" ). isClient (), GameEngine = function ( resources , found ) -- Load the client or server version of the game engine: if resources . isClient then return resources . require . ClientGameEngine else return resources . require . ServerGameEngine end end , InitializedGameEngine = function ( resources , found ) -- Do some expensive initialization logic here, just once. return resources . GameEngine . initialize () end , }}) -- Acquire the resource named \"InitializedGameEngine\": local engine = resources . InitializedGameEngine -- By default, resources are cached, and won't be initialized twice: print ( engine == resources . InitializedGameEngine ) -- true Caching behavior can be controlled by invoking Resourceful with a custom configuration. Robust, Developer-Friendly Error Handling For Resource Acquisition \u00b6 Resourceful implements error handling around all of its critical operations, ensuring that Resourceful isn't left in an unusable state after errors occur. Resourceful errors are reported to the developer in a clear and concise manner via the output console of Roblox Studio. Instead of receiving cryptic error messages such as: ReplicatedStorage.Scripts.Lib.SuperCool:42: invalid argument #1 to 'concat' (table expected, got nil) Resourceful provides meaningful error messages: ReplicatedStorage.Scripts.Lib.SuperCool:42: Resourceful resource 'TableHelper' was neither found nor defined for SuperCool while resolving 'StringLib', 'Helpers', 'TableHelper', and strict mode is enabled These error messages are especially helpful for developers who use libraries authored by others. If you intend to write a library to be shared with others, consider using Resourceful to help your users identify resource acquisition issues more easily. Summary of Benefits \u00b6 Resourceful offers the following benefits: Simplified Syntax For Resource Acquisition Customizable Automatic Resource Acquisition Customizable, On-Demand (Lazy-Loaded) Resource Acquisition Robust, Developer-Friendly Error Handling For Resource Acquisition Learn More \u00b6 Read the Installation instructions to learn how to make Resourceful available within your projects. Read the API Reference to learn more about getting started with Resourceful, and how to customize its behavior.","title":"Overview"},{"location":"#resourceful-overview","text":"","title":"Resourceful: Overview"},{"location":"#simplified-syntax-for-resource-acquisition","text":"Resourceful is a Lua module that allows Roblox developers to use a simple dot notation syntax to access project resources from within their own scripts. local resources = require ( script . Parent . Resourceful ) -- Find a resource named \"MyHelpers\": local MyHelpers = resources . MyHelpers -- Find and require a ModuleScript named \"Main\": local Main = resources . require . Main","title":"Simplified Syntax For Resource Acquisition"},{"location":"#customizable-automatic-resource-acquisition","text":"By default, Resourceful offers automatic resource acquisition to search for requested resources within the immediate children of Resourceful's script.Parent : local resources = require ( script . Parent . Resourceful ) -- Automatically find a resource named \"MyHelpers\", -- which is a child Instance within script.Parent: local MyHelpers = resources . MyHelpers -- Automatically find and require a ModuleScript named \"Main\", -- which is also a child Instance within script.Parent: local Main = resources . require . Main By invoking Resourceful with a custom configuration , the list of Roblox project paths that are searched during automatic resource acquisition can be specified. For example, to specify a search path consisting of script.Parent and script.Parent.Parent : local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ search = { script . Parent , script . Parent . Parent }}) --[[ Assuming the following project hierarchy: > Lib > Lib.MyLib > Lib.MyLib.Main > Lib.MyLib.MyHelpers > Lib.MyLib.Resourceful > Lib.MyLib.Script (this script) > Lib.ThirdPartyLib ]] -- -- Finds \"MyHelpers\" in Lib.MyLib (script.Parent) local MyHelpers = resources . MyHelpers -- Finds \"Main\" in Lib.MyLib (script.Parent), and requires it local Main = resources . require . Main -- Finds \"MyLib\" in Lib (script.Parent.Parent), and requires it local MyLib = resources . require . MyLib -- Finds \"ThirdPartyLib\" in Lib (script.Parent.Parent) local ThirdPartyLib = resources . ThirdPartyLib","title":"Customizable, Automatic Resource Acquisition"},{"location":"#customizable-on-demand-lazy-loaded-resource-acquisition","text":"Resourceful can be customized to also support the definition and creation of custom project resources , as simple or as complex as needed: local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { -- Custom resource loaders PlayerLib = function ( resources , found ) -- When \"resources.PlayerLib\" is requested, for 90% of players it should -- return the normal \"PlayerLib\" Instance child of the script parent: if math.random ( 100 ) <= 90 then return found else -- For the remaining players, \"resources.PlayerLib\" should instead -- return the \"TestPlayerLib\" Instance child of the script parent: return resources . TestPlayerLib end end , }}) -- For 10% of players, PlayerLib actually will be \"TestPlayerLib\": local PlayerLib = resources . require . PlayerLib Resourceful can be configured to support custom resources of any data type, including resource functions that return a resource. Such functions are not executed until requested, allowing on-demand, deferred, lazy-loading of resources that are cached by default for better performance: local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { -- Custom resource loaders isClient = game : GetService ( \"RunService\" ). isClient (), GameEngine = function ( resources , found ) -- Load the client or server version of the game engine: if resources . isClient then return resources . require . ClientGameEngine else return resources . require . ServerGameEngine end end , InitializedGameEngine = function ( resources , found ) -- Do some expensive initialization logic here, just once. return resources . GameEngine . initialize () end , }}) -- Acquire the resource named \"InitializedGameEngine\": local engine = resources . InitializedGameEngine -- By default, resources are cached, and won't be initialized twice: print ( engine == resources . InitializedGameEngine ) -- true Caching behavior can be controlled by invoking Resourceful with a custom configuration.","title":"Customizable, On-Demand (Lazy-Loaded) Resource Acquisition"},{"location":"#robust-developer-friendly-error-handling-for-resource-acquisition","text":"Resourceful implements error handling around all of its critical operations, ensuring that Resourceful isn't left in an unusable state after errors occur. Resourceful errors are reported to the developer in a clear and concise manner via the output console of Roblox Studio. Instead of receiving cryptic error messages such as: ReplicatedStorage.Scripts.Lib.SuperCool:42: invalid argument #1 to 'concat' (table expected, got nil) Resourceful provides meaningful error messages: ReplicatedStorage.Scripts.Lib.SuperCool:42: Resourceful resource 'TableHelper' was neither found nor defined for SuperCool while resolving 'StringLib', 'Helpers', 'TableHelper', and strict mode is enabled These error messages are especially helpful for developers who use libraries authored by others. If you intend to write a library to be shared with others, consider using Resourceful to help your users identify resource acquisition issues more easily.","title":"Robust, Developer-Friendly Error Handling For Resource Acquisition"},{"location":"#summary-of-benefits","text":"Resourceful offers the following benefits: Simplified Syntax For Resource Acquisition Customizable Automatic Resource Acquisition Customizable, On-Demand (Lazy-Loaded) Resource Acquisition Robust, Developer-Friendly Error Handling For Resource Acquisition","title":"Summary of Benefits"},{"location":"#learn-more","text":"Read the Installation instructions to learn how to make Resourceful available within your projects. Read the API Reference to learn more about getting started with Resourceful, and how to customize its behavior.","title":"Learn More"},{"location":"api-reference/","text":"Resourceful: API Reference \u00b6 Loading The Module \u00b6 Invoking require() upon the Resourceful module will return a Resourceful instance configured with default behavior, which can be used to acquire project resources using a clean syntax with robust error handling. Acquiring Resources \u00b6 Acquiring resources is as simple as instantiating Resourceful, and specifying the name of the resource to be acquired: local resources = require ( script . Parent . Resourceful ) local MyHelpers = resources . MyHelpers -- Find resource \"MyHelpers\" Requiring Resources \u00b6 Prepending the resource name with require causes Resourceful to issue require() upon the resource, which is expected to be a ModuleScript : local resources = require ( script . Parent . Resourceful ) local Main = resources . require . Main -- Equivalent to: local Main = require(resources.Main) -- but offers additional error-handling! If an error occurs when invoking require() , or if the specified resource is not a ModuleScript , Resourceful will wrap and throw the error with Resourceful's own error message. Automatic Resource Acquisition \u00b6 By default, Resourceful offers automatic resource acquisition to search for requested resources within the immediate children of Resourceful's script.Parent : local resources = require ( script . Parent . Resourceful ) -- Automatically find a resource named \"MyHelpers\", -- which is a child Instance within script.Parent: local MyHelpers = resources . MyHelpers -- Automatically find and require a ModuleScript named \"Main\", -- which is also a child Instance within script.Parent: local Main = resources . require . Main Resourceful() can be invoked to create a Resourceful instance with customized behavior. Class Methods \u00b6 Function Name Description Resourceful() Creates and returns a Resourceful instance with customized behavior, if a custom configuration is specified, or default behavior, if none is specified. Function: Resourceful() \u00b6 Resourceful() can be invoked to create a Resourceful instance with customized behavior ( example ), which can: allow multiple Instance objects to be searched when looking for resources define custom resources , including resource functions to acquire resources on-demand enable or disable caching of resources cause missing resources to return nil instead of throwing an error Signature \u00b6 Resourceful Resourceful ([ table config ]) Parameters \u00b6 Name Type Synopsis config table (optional) Contains configuration properties to define the behavior of the Resourceful object to be created and returned. If not specified, a Resourceful object with default behavior will be returned. Returns \u00b6 Type(s) Synopsis Resourceful The Resourceful object configured according to the specified config , or with default behavior if config was not specified. Side-Effects \u00b6 Resourceful() will execute the resource function config.resources.__init , if it has been defined. Errors \u00b6 Resourceful() will throw an error if config is present but is not a table . Resourceful() will throw an error if config contains a known property with an invalid value. Errors that occur during the execution of optional resource function __init will be wrapped and thrown by Resourceful. Caveats \u00b6 None. Examples \u00b6 Example: Customized Behavior local Resourceful = require ( script . Parent . Resourceful ) local configOptions = { -- Custom configuration options go here -- (details omitted for brevity) } -- Create an instance of Resourceful with customized behavior: local resources = Resourceful ( configOptions ) local otherConfigOptions = { -- An example of another custom configuration -- (details omitted for brevity) } -- Multiple instances of Resourceful, each with customized behavior, can be -- used simultaneously. local otherResources = Resourceful ( otherConfigOptions ) -- Using the customized Resourceful instance: local MyHelperLib = resources . require . MyHelperLib -- Using the other customized Resourceful instance: local ThirdPartyLib = otherResources . require . ThirdPartyLib config Properties \u00b6 Name Type Synopsis isCached boolean (optional) When true , causes Resourceful to memorize the value of requested resources when they are first requested, returning those values during subsequent requests. Defaults to true . ( More details ) isStrict boolean (optional) When true , causes Resourceful to throw an error when a requested resource is nil or doesn't exist. Defaults to true . ( More details ) name string (optional) When specified, is reported in error messages thrown by Resourceful. Defaults to nil . ( More details ) resources table (optional) Contains zero or more resource definitions, of any type of data, to be made available for resource acquisition. Defaults to {} . ( More details ) search Instance , or table of Instance objects (optional) An Instance object, or table of zero or more Instance objects, to be searched when automatically acquiring resources. Defaults to the Parent of the Resourceful Instance . ( More details ) config Property: isCached \u00b6 isCached is an optional boolean parameter that, when true , causes Resourceful to memorize the value of requested resources when they are first requested, returning those values during subsequent requests. Defaults to true . Memorized values can improve performance for resource functions that take time to execute. For Instance resources found during automatic resource acquisition , memorized values prevent the need for traversing through the search path again. Errors \u00b6 Resourceful() will throw an error if config.isCached is present but is not a boolean . Examples \u00b6 Example: isCached local Resourceful = require ( script . Parent . Resourceful ) local cached = Resourceful ({ isCached = true , resources = { number = function ( resources , found ) return math.random ( 100 ) end }}) print ( cached . number ) -- 17 print ( cached . number ) -- 17 print ( cached . number ) -- 17 local not_cached = Resourceful ({ isCached = false , resources = { number = function ( resources , found ) return math.random ( 100 ) end }}) print ( not_cached . number ) -- 82 print ( not_cached . number ) -- 23 print ( not_cached . number ) -- 76 config Property: isStrict \u00b6 isStrict is an optional boolean parameter that, when true , causes Resourceful to thrown an error when a requested resource is nil or doesn't exist. Defaults to true . Errors \u00b6 Resourceful() will throw an error if config.isStrict is present but is not a boolean . Examples \u00b6 Example: isStrict local Resourceful = require ( script . Parent . Resourceful ) local strict = Resourceful ({ isStrict = true , resources = { Nil = function ( resources , found ) return nil end }}) print ( strict . Nil ) -- throws error print ( strict . missing ) -- throws error local not_strict = Resourceful ({ isStrict = false , resources = { Nil = function ( resources , found ) return nil end }}) print ( not_strict . Nil ) -- nil print ( not_strict . missing ) -- nil Note that even if isStrict is set to false , Resourceful will throw an error if a nil resource is preceded with the require : Example: isStrict With require local Resourceful = require ( script . Parent . Resourceful ) local not_strict = Resourceful ({ isStrict = false }) print ( not_strict . require . missing ) -- throws an error config Property: name \u00b6 name is an optional string parameter that, when specified, is reported in error messages thrown by Resourceful. Defaults to nil . When writing libraries to be shared with others, specifying a name can help users of your libraries to more easily identify and troubleshoot resource issues within your libraries. Errors \u00b6 Resourceful() will throw an error if config.name is present but is not a string . Examples \u00b6 Example: name local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ name = \"MyLib\" }) config Property: resources \u00b6 resources is an optional table parameter of zero or more resource definitions, of any type of data, to be made available for resource acquisition. Defaults to {} . The name of each element within resources defines the name of a custom resource that can be acquired. An element's corresponding value defines the value of that resource. Resources that are assigned a data type other than function are returned immediately by Resourceful whenever those resources are requested. In this case, Resourceful will not search for similarly named Instance children located within the defined search path , thus bypassing automatic resource acquisition . For resources that are defined as functions, including the special resource named __init , please refer to Resource Functions . Errors \u00b6 Resourceful() will throw an error if config.resources is present but is not a table . Errors that occur during the execution of optional resource function __init will be wrapped and thrown by Resourceful. Examples \u00b6 Example: resources local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { boolResource = true , numResource = 3.14 , strResource = \"hello\" , tableResource = { value = true }, strResourceFn = function ( resources , found ) return \"Hello!\" end , functionResource = function ( resources , found ) return function ( name ) return ( \"Hi, %s!\" ): format ( name ) end end , __init = function ( resources , found ) print ( \"Initializing resources!\" ) end , }}) -- \"Initializing resources!\" will be printed here, -- because the above invocation of Resourceful() -- will execute resource function __init. print ( resources . boolResource ) -- true print ( resources . numResource ) -- 3.14 print ( resources . strResource ) -- \"hello\" print ( resources . tableResource . value ) -- true print ( resources . strResourceFn ) -- \"Hello!\" print ( resources . functionResource ( \"person\" )) -- \"Hi, person!\" config Property: search \u00b6 search is an optional Instance , or table of Instance objects, to be searched when automatically acquiring resources. Note that specifying an empty table effectively disables Resourceful's automatic resource acquisition . Defaults to the Parent of the Resourceful Instance . If multiple Instance objects are specified, they are searched in the order in which they are specified, until the first Instance is found with an immediate child whose name matches the requested resource. If a custom resource of the same name is defined, and the resource is not a resource function , that resource will be used, bypassing automatic resource acquisition. However, if the resource is a resource function, automatic resource acquisition will be performed, with the acquired resource being passed to the resource function as a function parameter . The function can thus decide whether to return that Instance , or some other value, as the definition of the resource. Searching is performed by executing :FindFirstChild(resourceName, false) on each search target, where resourceName is the string name of the resource to be found, and false instructs Roblox to search only the immediate children of the search targets, and not deeper descendants. Errors \u00b6 Resourceful() will throw an error if config.search is present but has a type other than Instance , empty table , or table of Instance objects. Examples \u00b6 Example: search local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ search = { script . Parent , script . Parent . Parent , game : GetService ( \"ReplicatedStorage\" ): FindFirstChild ( \"Scripts\" , false ), }}) -- Resourceful searches for the following \"Helpers\" instances: -- script.Parent.Helpers -- script.Parent.Parent.Helpers -- game:GetService(\"ReplicatedStorage\").Scripts.Helpers local Helpers = resources . Helpers Resource Functions \u00b6 If a custom resource is defined as a function , the function will be executed to define the actual value of the resource: Example: Resource Function local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { greeting = function ( resources , found ) return \"Hello!\" end , }}) print ( resources . greeting ) -- Hello! Since functions are not executed until their corresponding resources are first requested, the acquisition of these resources is said to be deferred , or lazy-loaded . This can be beneficial when: the initialization of the resource has a performance penalty this is better incurred when the resource is first needed the resource cannot be initialized until some other component has been prepared first If caching is enabled, the results of the function execution will be memorized, and returned for all future requests of that resource: Example: Resource Function Caching local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { number = function ( resources , found ) return math.random ( 100 ) end , }}) print ( resources . number ) -- 41 print ( resources . number ) -- 41 again, because caching is enabled With caching disabled, the function is executed each time its corresponding resource is requested: Example: Resource Function Without Caching local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ isCached = false , resources = { number = function ( resources , found ) return math.random ( 100 ) end , }}) print ( resources . number ) -- 41 print ( resources . number ) -- 87 Signature \u00b6 Resource functions are invoked with the following signature: function ( table resources , Instance found ) return Variant Parameters \u00b6 Name Type Synopsis resources table The same table for acquiring resources that was returned from Resourceful() , which allows the function to acquire other resources. ( More details ). found Instance The first Instance found within the configured search path that has the same name as the requested resource, representing the resource that would have been returned if a resource function by the same name were not defined. ( More details ). Returns \u00b6 Type(s) Synopsis Variant (optional) Resource functions can return any data type, whose value will be used as the value of the acquired resource. Side-Effects \u00b6 Resource functions perform whatever side-effects they were programmed to perform. Errors \u00b6 Resource functions will throw whatever errors they were programmed to throw. Any such errors will be wrapped and thrown by Resourceful. If a resource function returns nil and strict mode is enabled, Resourceful will throw an error. Circular references amongst resources will cause Resourceful to throw an error. Caveats \u00b6 None. Parameter: resources \u00b6 resources is the same table for acquiring resources that was returned from Resourceful() , which allows the function to acquire other resources. Example: Resource Chaining local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { ceiling = 5 , getNumber = function ( resources , found ) return function ( floor ) return floor + math.random ( resources . ceiling - floor ) end end , }}) print ( resources . getNumber ( 2 )) -- 4 print ( resources . getNumber ( 2 )) -- 2 Note that circular references amongst resources will cause Resourceful to throw an error. Example: Resource Function, Circular Reference local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { truthy = function ( resources , found ) return not resources . falsey end , falsey = function ( resources , found ) return not resources . truthy end , }}) print ( resources . truthy ()) -- throws an error Parameter: found \u00b6 found is the first Instance found within the configured search path that has the same name as the requested resource, representing the resource that would have been returned if a resource function by the same name were not defined. The found parameter effectively lets the function choose to conditionally override that resource when appropriate. Example: Resource Function, Conditional local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { PlayerLib = function ( resources , found ) -- When \"resources.PlayerLib\" is requested, for 90% of players it should -- return the normal \"PlayerLib\" Instance child of the script parent: if math.random ( 100 ) <= 90 then return found else -- For the remaining players, \"resources.PlayerLib\" should instead -- return the \"TestPlayerLib\" Instance child of the script parent: return resources . TestPlayerLib end end , }}) -- For 10% of players, PlayerLib actually will be \"TestPlayerLib\": local PlayerLib = resources . require . PlayerLib __init Resource Function \u00b6 If a special resource function named __init is defined, Resourceful will execute that function when Resourceful() is invoked. __init is an appropriate location to perform common initialization logic that is needed by other custom resources , especially those whose initialization should be executed as soon as possible. Example: __init Resource Function local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { __init = function ( resources , found ) return { -- Do some expensive initialization logic here, -- just once, as soon as Resourceful() is invoked. InitializedGameEngine = resources . GameEngine . initialize (), } end , isClient = game : GetService ( \"RunService\" ). isClient (), GameEngine = function ( resources , found ) -- Load the client or server version of the game engine: if resources . isClient then return resources . require . ClientGameEngine else return resources . require . ServerGameEngine end end , InitializedGameEngine = function ( resources , found ) -- Return the game engine that was initialized -- when Resourceful() was invoked. return resources . __init . InitializedGameEngine end , }}) -- Acquire the resource named \"InitializedGameEngine\": local engine = resources . InitializedGameEngine __init is executed with the same function signature as other resource functions, although its found parameter will always be nil . The return value of __init can be acquired and cached like any other resource. If __init is defined but is not a function , it will be behave like any other non-function custom resource . Learn More \u00b6 Read the Overview to learn how Resourceful can solve common resource acquisition problems. Read the Installation instructions to learn how to make Resourceful available within your projects.","title":"API Reference"},{"location":"api-reference/#resourceful-api-reference","text":"","title":"Resourceful: API Reference"},{"location":"api-reference/#loading-the-module","text":"Invoking require() upon the Resourceful module will return a Resourceful instance configured with default behavior, which can be used to acquire project resources using a clean syntax with robust error handling.","title":"Loading The Module"},{"location":"api-reference/#acquiring-resources","text":"Acquiring resources is as simple as instantiating Resourceful, and specifying the name of the resource to be acquired: local resources = require ( script . Parent . Resourceful ) local MyHelpers = resources . MyHelpers -- Find resource \"MyHelpers\"","title":"Acquiring Resources"},{"location":"api-reference/#requiring-resources","text":"Prepending the resource name with require causes Resourceful to issue require() upon the resource, which is expected to be a ModuleScript : local resources = require ( script . Parent . Resourceful ) local Main = resources . require . Main -- Equivalent to: local Main = require(resources.Main) -- but offers additional error-handling! If an error occurs when invoking require() , or if the specified resource is not a ModuleScript , Resourceful will wrap and throw the error with Resourceful's own error message.","title":"Requiring Resources"},{"location":"api-reference/#automatic-resource-acquisition","text":"By default, Resourceful offers automatic resource acquisition to search for requested resources within the immediate children of Resourceful's script.Parent : local resources = require ( script . Parent . Resourceful ) -- Automatically find a resource named \"MyHelpers\", -- which is a child Instance within script.Parent: local MyHelpers = resources . MyHelpers -- Automatically find and require a ModuleScript named \"Main\", -- which is also a child Instance within script.Parent: local Main = resources . require . Main Resourceful() can be invoked to create a Resourceful instance with customized behavior.","title":"Automatic Resource Acquisition"},{"location":"api-reference/#class-methods","text":"Function Name Description Resourceful() Creates and returns a Resourceful instance with customized behavior, if a custom configuration is specified, or default behavior, if none is specified.","title":"Class Methods"},{"location":"api-reference/#function-resourceful","text":"Resourceful() can be invoked to create a Resourceful instance with customized behavior ( example ), which can: allow multiple Instance objects to be searched when looking for resources define custom resources , including resource functions to acquire resources on-demand enable or disable caching of resources cause missing resources to return nil instead of throwing an error","title":"Function: Resourceful()"},{"location":"api-reference/#config-properties","text":"Name Type Synopsis isCached boolean (optional) When true , causes Resourceful to memorize the value of requested resources when they are first requested, returning those values during subsequent requests. Defaults to true . ( More details ) isStrict boolean (optional) When true , causes Resourceful to throw an error when a requested resource is nil or doesn't exist. Defaults to true . ( More details ) name string (optional) When specified, is reported in error messages thrown by Resourceful. Defaults to nil . ( More details ) resources table (optional) Contains zero or more resource definitions, of any type of data, to be made available for resource acquisition. Defaults to {} . ( More details ) search Instance , or table of Instance objects (optional) An Instance object, or table of zero or more Instance objects, to be searched when automatically acquiring resources. Defaults to the Parent of the Resourceful Instance . ( More details )","title":"config Properties"},{"location":"api-reference/#resource-functions","text":"If a custom resource is defined as a function , the function will be executed to define the actual value of the resource: Example: Resource Function local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { greeting = function ( resources , found ) return \"Hello!\" end , }}) print ( resources . greeting ) -- Hello! Since functions are not executed until their corresponding resources are first requested, the acquisition of these resources is said to be deferred , or lazy-loaded . This can be beneficial when: the initialization of the resource has a performance penalty this is better incurred when the resource is first needed the resource cannot be initialized until some other component has been prepared first If caching is enabled, the results of the function execution will be memorized, and returned for all future requests of that resource: Example: Resource Function Caching local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ resources = { number = function ( resources , found ) return math.random ( 100 ) end , }}) print ( resources . number ) -- 41 print ( resources . number ) -- 41 again, because caching is enabled With caching disabled, the function is executed each time its corresponding resource is requested: Example: Resource Function Without Caching local Resourceful = require ( script . Parent . Resourceful ) local resources = Resourceful ({ isCached = false , resources = { number = function ( resources , found ) return math.random ( 100 ) end , }}) print ( resources . number ) -- 41 print ( resources . number ) -- 87","title":"Resource Functions"},{"location":"api-reference/#learn-more","text":"Read the Overview to learn how Resourceful can solve common resource acquisition problems. Read the Installation instructions to learn how to make Resourceful available within your projects.","title":"Learn More"},{"location":"changelog/","text":"Resourceful: Changelog \u00b6 1.0.2 (2021-06-05) \u00b6 Added \u00b6 New version of default.project.json which outputs a Folder instead of DataModel Example tests in tests/Resourceful/examples.lua Selene configuration file for linting Basic VSCode Workspace Changed \u00b6 Renamed default.project.json to place.project.json Renamed Resourceful.rbxlx to Resourceful-place.rbxlx Renamed test.project.json to tests.project.json Renamed test.rbxlx to Resourceful-tests.rbxlx Updated documentation to new style and API format Removed \u00b6 onError hooks from src/Resourceful/init.lua 1.0.1 (2021-05-15) \u00b6 Added \u00b6 rotriever.toml 1.0.0 (2021-05-15) \u00b6 Initial release. Added \u00b6 Everything. Hello, world! The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#resourceful-changelog","text":"","title":"Resourceful: Changelog"},{"location":"changelog/#102-2021-06-05","text":"","title":"1.0.2 (2021-06-05)"},{"location":"changelog/#101-2021-05-15","text":"","title":"1.0.1 (2021-05-15)"},{"location":"changelog/#100-2021-05-15","text":"Initial release.","title":"1.0.0 (2021-05-15)"},{"location":"installation/","text":"Resourceful: Installation \u00b6 Choosing Where To Install Resourceful \u00b6 Within a Roblox Studio project, Resourceful can be installed to a single, shared location where it can be accessed by all project modules that will use it. Conversely, it can also be installed as a child within each module that will use it. Installing Resourceful to a shared location can ensure that a single, known version of Resourceful is used across all modules, while also reducing the file size of the Roblox project. Installing Resourceful as a child within each module that uses Resourceful may help simplify the sharing of such modules with other projects, which can be useful for module libraries. Understanding The Resourceful Search Path \u00b6 When invoking Resourceful with default behavior, Resourceful will automatically search for resources in the parent Instance that contains Resourceful. Thus, if Resourceful is installed to a shared location, invoking that instance of Resourceful with default behavior will search for resources within that shared location. If Resourceful is installed as a child within a module, invoking that instance of Resourceful with default behavior will search for resources within that module. Installing Resourceful to multiple modules would allow each such module to search itself when acquiring resources. Each invocation of Resourceful can also be configured with custom search paths that are as simple or complex as needed. This can allow every module within a project to use a shared instance of Resourceful, while also allowing each module to find the specific resources it needs. Choosing How To Install Resourceful \u00b6 Resourceful can be installed by loading a Resourceful model file into Roblox Studio, or by using a developer tool to synchronize Resourceful's source code into a Roblox Studio project. Loading A Resourceful Model File Into Roblox Studio \u00b6 Obtain the latest version of Resourceful.rbxmx from the GitHub Release Page Insert the model into the chosen parent object(s) within a Roblox Studio project Using A Developer Tool To Synchronize Resourceful \u00b6 Developers who use tools such as Rojo or Remodel can copy the Resourceful source code to the appropriate location(s): Download or clone the source code for Resourceful into a local directory Copy or synchronize the src/Resourceful folder into a Roblox Studio project at the appropriate location(s). Ensure that the new Instance containing Resourceful is named Resourceful . Learn More \u00b6 Read the Overview to learn how Resourceful can solve common resource acquisition problems. Read the API Reference to learn more about getting started with Resourceful, and how to customize its behavior.","title":"Installation"},{"location":"installation/#resourceful-installation","text":"","title":"Resourceful: Installation"},{"location":"installation/#choosing-where-to-install-resourceful","text":"Within a Roblox Studio project, Resourceful can be installed to a single, shared location where it can be accessed by all project modules that will use it. Conversely, it can also be installed as a child within each module that will use it. Installing Resourceful to a shared location can ensure that a single, known version of Resourceful is used across all modules, while also reducing the file size of the Roblox project. Installing Resourceful as a child within each module that uses Resourceful may help simplify the sharing of such modules with other projects, which can be useful for module libraries.","title":"Choosing Where To Install Resourceful"},{"location":"installation/#understanding-the-resourceful-search-path","text":"When invoking Resourceful with default behavior, Resourceful will automatically search for resources in the parent Instance that contains Resourceful. Thus, if Resourceful is installed to a shared location, invoking that instance of Resourceful with default behavior will search for resources within that shared location. If Resourceful is installed as a child within a module, invoking that instance of Resourceful with default behavior will search for resources within that module. Installing Resourceful to multiple modules would allow each such module to search itself when acquiring resources. Each invocation of Resourceful can also be configured with custom search paths that are as simple or complex as needed. This can allow every module within a project to use a shared instance of Resourceful, while also allowing each module to find the specific resources it needs.","title":"Understanding The Resourceful Search Path"},{"location":"installation/#choosing-how-to-install-resourceful","text":"Resourceful can be installed by loading a Resourceful model file into Roblox Studio, or by using a developer tool to synchronize Resourceful's source code into a Roblox Studio project.","title":"Choosing How To Install Resourceful"},{"location":"installation/#loading-a-resourceful-model-file-into-roblox-studio","text":"Obtain the latest version of Resourceful.rbxmx from the GitHub Release Page Insert the model into the chosen parent object(s) within a Roblox Studio project","title":"Loading A Resourceful Model File Into Roblox Studio"},{"location":"installation/#using-a-developer-tool-to-synchronize-resourceful","text":"Developers who use tools such as Rojo or Remodel can copy the Resourceful source code to the appropriate location(s): Download or clone the source code for Resourceful into a local directory Copy or synchronize the src/Resourceful folder into a Roblox Studio project at the appropriate location(s). Ensure that the new Instance containing Resourceful is named Resourceful .","title":"Using A Developer Tool To Synchronize Resourceful"},{"location":"installation/#learn-more","text":"Read the Overview to learn how Resourceful can solve common resource acquisition problems. Read the API Reference to learn more about getting started with Resourceful, and how to customize its behavior.","title":"Learn More"},{"location":"license/","text":"MIT License Copyright (c) 2021 BetterThanReal Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"}]}